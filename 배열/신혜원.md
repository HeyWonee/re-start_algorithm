<!-- 7/17일 배운 것 -->
```
1. 행렬 전환 시 list(zip(*arr)) 사용
2. from math import prod : 리스트 곱 사용
```


## 행렬의 곱셈

```
from math import prod

def solution(arr1, arr2):

    #     앞 행렬의 열과, 뒤 행렬의 행이 같아야만 곱할 수 있음
    # 행렬의 크기는 앞의 행의 행, 뒤의 행의 열

    n, m = len(arr1), len(arr2[0])

    answer = [[0] * m for _ in range(n)]
#     행렬 전환
    arr2 = list(zip(*arr2))
    for i in range(n):
        for j in range(m):
#             prod : 배열의 인수들을 곱해줌
            answer[i][j] = list(map(prod, zip(arr1[i], arr2[j])))

    for i in range(n):
        for j in range(m):
            answer[i][j] = sum(answer[i][j])

    return answer
```

## 삼각 달팽이

```
def solution(n):


    if n == 1:
        return [1]
    if n == 2:
        return [1, 2, 3]
    answer = []

    # 바닥 = 2n-1

    arr = [[0] * (2 * n - 1) for _ in range(n)]

    direction = [[1, -1], [0, 2], [-1, -1]]

    k = 1
    pos = 0

    ci, cj = 0, (2 * n - 1) // 2
    di, dj = direction[pos]
    while True:
        arr[ci][cj] = k

        #         ci, cj를 다음 진행할 수 있는지 확인
        # 1) index range 2) 숫자인지
        # index range 밖이면 pos를 바꿔줌
        # pos가 1일 때는 2칸 옆으로

        ci, cj = ci + di, cj + dj

        if 0 <= ci < n and 0 <= cj < 2 * n - 1 and arr[ci][cj] == 0:
            k += 1

        #             인덱스 밖이면 방향전환
        elif not 0 <= ci < n or not 0 <= cj < 2 * n - 1:
            pos = (pos + 1) % 3
            ci, cj = ci - di, cj - dj
            di, dj = direction[pos]


        #         차잇으면
        elif arr[ci][cj]:
            #             방향전환하고 다음 확인인데 또 차잇으면 그때 끝
            pos = (pos + 1) % 3
            ci, cj = ci - di, cj - dj
            di, dj = direction[pos]
            ci, cj = ci + di, cj + dj
            if arr[ci][cj]:
                break
            else:
                k += 1
``
    for i in arr:
        for j in i:
            if j:
                answer.append(j)


    return answer
```
